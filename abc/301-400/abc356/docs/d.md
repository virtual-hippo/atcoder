# 具体例で解説：ビット位置が1になる個数を高速に数える方法

## 具体例1：n=13, i=2（2ビット目）

0から13までの整数について考えます。2ビット目（4の位）が立っている数を数えましょう。

各数値を2進数で表すと：
```
0:  0000  (2ビット目は0)
1:  0001  (2ビット目は0)
2:  0010  (2ビット目は0)
3:  0011  (2ビット目は0)
4:  0100  (2ビット目は1) ←
5:  0101  (2ビット目は1) ←
6:  0110  (2ビット目は1) ←
7:  0111  (2ビット目は1) ←
8:  1000  (2ビット目は0)
9:  1001  (2ビット目は0)
10: 1010  (2ビット目は0)
11: 1011  (2ビット目は0)
12: 1100  (2ビット目は1) ←
13: 1101  (2ビット目は1) ←
```

計算過程：
1. `cnt = (n >> (i + 1)) << i`
   - n=14（問題では`n+1`を使っているため）、i=2
   - `14 >> 3 = 1`（14÷8=1余り6）
   - `1 << 2 = 4`
   - これは、「8個ずつのブロック」が1個あり、その中に4個の1がある計算

2. `rem = n & ((1 << (i + 1)) - 1)`
   - `(1 << 3) - 1 = 8 - 1 = 7`（二進数で111）
   - `14 & 7 = 6`（14の下位3ビットは110）
   - これは余りの部分が6個あることを示す

3. `cnt = cnt + rem.saturating_sub(1 << i)`
   - `1 << 2 = 4`
   - `6 - 4 = 2`（余り部分で2ビット目が1になるのは2個）
   - `4 + 2 = 6`

よって、0から13までの整数で2ビット目が1になるのは6個。
実際に数えると：4,5,6,7,12,13の6個で一致します。

## 具体例2：n=20, i=3（3ビット目）

0から20までの整数について、3ビット目（8の位）が立っている数を数えます。

各数値を2進数で表すと：
```
0:  00000  (3ビット目は0)
...
7:  00111  (3ビット目は0)
8:  01000  (3ビット目は1) ←
9:  01001  (3ビット目は1) ←
...
15: 01111  (3ビット目は1) ←
16: 10000  (3ビット目は0)
...
20: 10100  (3ビット目は0)
```

計算過程：
1. `cnt = (n >> (i + 1)) << i`
   - n=21（問題では`n+1`を使用）、i=3
   - `21 >> 4 = 1`（21÷16=1余り5）
   - `1 << 3 = 8`
   - 「16個ずつのブロック」が1個あり、その中に8個の1がある

2. `rem = n & ((1 << (i + 1)) - 1)`
   - `(1 << 4) - 1 = 16 - 1 = 15`（二進数で1111）
   - `21 & 15 = 5`（21の下位4ビットは0101）
   - 余りの部分が5個あることを示す

3. `cnt = cnt + rem.saturating_sub(1 << i)`
   - `1 << 3 = 8`
   - `5 - 8 = -3` → `saturating_sub`で0になる
   - `8 + 0 = 8`

よって、0から20までの整数で3ビット目が1になるのは8個。
実際に数えると：8,9,10,11,12,13,14,15の8個で一致します。

## ビットパターンの規則性

iビット目（2^iの位）について：
- 2^(i+1)ごとに、連続する2^i個の数でiビット目が1になる
- 例えば2ビット目なら8個ごとに4個の数字で1になる
- 例えば3ビット目なら16個ごとに8個の数字で1になる

このパターンを利用することで、ループを使わずに高速に計算できるのがこのコードの優れた点です！